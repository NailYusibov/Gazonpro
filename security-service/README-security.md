Отвечает за аутентификацию и авторизацию пользователей:

1. Регистрация пользователей
2. Проверка прав пользователей на доступ к какому-либо ресурсу

### Базовая реализация Security
Защита сервисов осуществляется через API Gateway

  ![Схема](/Users/jormund/IdeaProjects/p_dp_ecommerce_1/guides/images/JWT_security.png)
Все запросы через **localhost:8081** 
- если в запросе есть /auth/*** - запрос перенаправляется на **localhost:8083** (Security Service) на один из "открытых" путей 
  - `/auth/register` - регистрация нового пользователя (с шифрованием пароля BCrypt)
  - `/auth/token` - получение JWT токена (если пользователь существует)
  - Эндпойнт верификации `/auth/validate` требует наличие валидного токена в header запроса
- если в запросе есть /api/*** - запрос перенаправляется на **localhost:8080** (Gazon Service). Фильтр аутентификации проверяет есть ли в запросе header авторизации с валидным токеном. Если есть - пропускает запрос на gazon, если нет - выдает ошибку авторизации (401)

### Аутентификация и авторизация с помощью JWT через Postman

Существует два основных подхода аутентификации пользователей: токены и сессии.
- Сессии - это классический подход. Пользователь передает логин и пароль серверу, сервер проверяет полученные данные и сохраняет сессию либо в БД, либо In-memory (в оперативной памяти), пользователю возвращается Session ID - сгенерированная строка, которую пользователь передает в http-заголовке при последующих запросах к серверу, а сервер по этому Session ID ищет информацию о ранее залогиненном пользователе. В результате имеем stateful подход. Главный недостаток такого подхода в необходимости серверу хранить информацию о сессии, что может негативно сказаться на работе высоконагруженного приложения.
- Токены - более современных подход. Пользователь передает логин и пароль серверу, сервер проверяет полученные данные, но вместо сохранения сессии генерируется так называемый токен, который хранит в себе зашифрованную информацию о залогиненом пользователей. Пользователь сохраняет этот токен и использует в дальнейших запросах серверу. При этом сервер не хранит информацию о ранее выданном токене, а проверяет его подлинность в момент получения запроса без обращения к какому-либо хранилищу. Это stateless подход, и он позволяет более гибко и комфортно масштабировать высоконагруженные приложения. Основной реализацией такого подхода является JWT.

**JWT (JSON Web Token)** служит для безопасной передачи информации между двумя участниками (в нашем случае клиентом и сервером) [подробнее от JWT тут](https://struchkov.dev/blog/what-is-jwt/). Токен содержит:
- логин(email) и роль пользователя
- дату создания
- дату, после которой токен не валиден

Данные токена подписаны **HMAC-256** с использованием секретного ключа, известного только серверу аутентификации и серверу приложений(API Gateway) - т.о. сервер приложений, при получении токена, сможет проверить не менялись ли его данные с момента создания.
1) Пользователь посылает логин/пароль серверу аутентификации
2) Сервер аутентифицирует пользователя и возвращает ему **JWT**
3) К каждому запросу на сервер приложений пользователь прикрепляет **JWT**
4) На основе **JWT** сервер приложений авторизует пользователя и предоставляет доступ к ресурсу (или не предоставляет - если пользователь не прошел авторизацию или время валидности токена истекло)

Аутентификация на сервере:
- зайти в **Postman**
- создать POST запрос на ```/auth/token```
- в качестве тела запроса выбрать raw -> JSON
- вписать username(email) и password в JSON и выполнить запрос
- Если аутентификация прошла успешно сервер вернет **JWT** 
- 
Авторизация на сервере:
- Теперь, чтобы выполнить любой запрос к серверу нужно в **header** запроса создать ключ **Authorization** и в качестве значения написать ```Bearer ``` + полученный ранее токен (Bearer обязательно с пробелом)
  или зайти во вкладку ```Authorization```, в выпадающем списке блока ```Type``` выбрать ```Bearer Token```, в ```Token``` вставить полученный ```accessToken```
